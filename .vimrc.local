" Neovim config to display command in a split window
if has('nvim')
    set inccommand=split
endif

set cursorline " highlight current line
let test#strategy = "dispatch"
" let test#filename_modifier = ":p"

" Fix issue with tmuxnavigator and tmp files
" https://github.com/christoomey/vim-tmux-navigator/issues/105
let $TMPDIR = $HOME."/tmp"

" Mappings for vim-test
nmap <leader>tn :TestNearest<CR>
nmap <leader>tf :TestFile<CR>
nmap <leader>ts :TestSuite<CR>
nmap <leader>tl :TestLast<CR>
nmap <leader>tv :TestVisit<CR>

" Vim format mappings
let g:mix_format_on_save = 1
let g:mix_format_silent_errors = 1

" highlight search
set hlsearch

" Remove search highlight
" nnoremap <leader><space> :nohlsearch<CR>
function! s:clear_highlight()
  let @/ = ""
  call go#guru#ClearSameIds()
endfunction
nnoremap <silent> <leader><space> :<C-u>call <SID>clear_highlight()<CR>

" Fast saving
nmap <leader>w :w!<cr>

set autowrite
set nowritebackup
set whichwrap+=<,>,h,l,[,] " Wrap arrow keys between lines

" This allows to switch tmux windows vertically from NerdTree
" Bug documented here: https://github.com/christoomey/vim-tmux-navigator/issues/83
let g:NERDTreeMapJumpNextSibling = '<Nop>'
let g:NERDTreeMapJumpPrevSibling = '<Nop>'
" Let NerdTree show hiden files
let NERDTreeShowHidden=1
" Config win size
let g:NERDTreeAutoDeleteBuffer=1
let g:NERDTreeQuitOnOpen=0
let g:NERDTreeMinimalUI = 1

" open nerd tree on open
autocmd vimenter * if !argc() | NERDTree | endif

" FZF {{{
" exclude .gitignore files plus .git folder and add hidden files
let $FZF_DEFAULT_COMMAND = 'rg --hidden -g "!.git" -l ""'
let $FZF_DEFAULT_OPTS = '--bind ctrl-a:select-all'

" show results in bottom layout
let g:fzf_layout = { 'down': '~40%' }
" enable history, so we can use ctrl-p and ctrl-n to see them
let g:fzf_history_dir = '~/.local/share/fzf-history'

" mappings
nnoremap <silent> <C-p> :FZF -m<CR>
nnoremap <silent> <Leader><CR> :Buffers<CR>
nnoremap <silent> <Leader>s :Snippets<CR>
nnoremap <silent> <Leader>` :Marks<CR>
" FZF }}}

" TagBar: Mappings plugin
let g:tagbar_type_elixir = {
    \ 'ctagstype' : 'elixir',
    \ 'kinds' : [
        \ 'p:protocols',
        \ 'm:modules',
        \ 'e:exceptions',
        \ 'y:types',
        \ 'd:delegates',
        \ 'f:functions',
        \ 'c:callbacks',
        \ 'a:macros',
        \ 't:tests',
        \ 'i:implementations',
        \ 'o:operators',
        \ 'r:records'
    \ ],
    \ 'sro' : '.',
    \ 'kind2scope' : {
        \ 'p' : 'protocol',
        \ 'm' : 'module'
    \ },
    \ 'scope2kind' : {
        \ 'protocol' : 'p',
        \ 'module' : 'm'
    \ },
    \ 'sort' : 0
\ }

" persistent vim history on disk
" Put plugins and dictionaries in this dir (also on Windows)
let vimDir = '$HOME/.vim'
let &runtimepath.=','.vimDir

" Keep undo history across sessions by storing it in a file
if has('persistent_undo')
    let myUndoDir = expand(vimDir . '/undodir')
    " Create dirs
    call system('mkdir ' . vimDir)
    call system('mkdir ' . myUndoDir)
    let &undodir = myUndoDir
    set undofile
endif

" ----Autocompletion--------
"
" don't automatically show dictionary words for autocompletion " trigger with ctrlp
set complete+=kspell
set completeopt=menuone,longest " configure dictionary in english
set spelllang=en_us
set nospell

" Don't update status bar in autocompletion
set shortmess+=c

" Toggle spell check.
map <F6> :setlocal spell!<CR>

" Autocomplete: Select the complete menu item like CTRL+y would.
inoremap <expr> <CR> pumvisible() ? "<C-y>" :"<CR>"

" Quickfix window {{{
function! ToggleQuickFix()
  if empty(filter(getwininfo(), 'v:val.quickfix'))
    copen
  else
    cclose
  endif
endfunction

nnoremap <silent> <leader>c :call ToggleQuickFix()<cr>

" Update a buffer's contents on focus if it changed outside of Vim.
au FocusGained,BufEnter * :checktime

" Toggle paste mode
set pastetoggle=<F5>
" Unset paste on InsertLeave.
autocmd InsertLeave * silent! set nopaste

" Press * to search for the term under the cursor or a visual selection and
" then press the key below to replace all instances of it in the current file.
nnoremap <Leader>r :%s///g<Left><Left>
nnoremap <Leader>rc :%s///gc<Left><Left><Left>

" The same as above but insteu of acting on the whole file it will be
" restricted to the previously visually selected range. You can do that by
" pressing *, visually selecting the range you want it to apply to and then
" press the key below to replace all instances of it in the current selection.
" (https://github.com/nickjj/dotfiles/blob/master/.)
xnoremap <Leader>r :s///g<Left><Left>
xnoremap <Leader>rc :s///gc<Left><Left><Left>

" Type a replacement term and press . to repeat the replacement again. Useful
" for replacing a few instances of the term (comparable to multiple cursors).
nnoremap <silent> s* :let @/='\<'.expand('<cword>').'\>'<CR>cgn
xnoremap <silent> s* "sy:let @/=@s<CR>cgn

" Swap begin of line keys for easy acces
noremap 0 ^
noremap ^ 0

" vim split on the right always
set splitright

" format/indent whole file keeping cursor at the same position
noremap =a gg=G<C-o><C-o>

" Keep cursor at the bottom of the visual selection after you yank it.
vmap y ygv<Esc>

" Prevent x from overriding what's in the clipboard.
noremap x "_x
noremap X "_x

" -----------------------------------------------------------------------------
" Color settings
" -----------------------------------------------------------------------------
"
" Instead of syntax on, use This
" to avoid problems with devicons
" https://github.com/ryanoasis/vim-devicons/issues/215#issuecomment-377782464
if !exists('g:syntax_on')
  syntax enable
endif


" Enable 24-bit true colors if your terminal supports it.
if (has("termguicolors"))
  " https://github.com/vim/vim/issues/993#issuecomment-255651605
  let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
  let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"

  set termguicolors
endif

" Set the color scheme to dark.
set background=dark

colorscheme one

" Trigger a highlight in the appropriate direction when pressing these keys.
let g:qs_highlight_on_keys=['f', 'F', 't', 'T']

highlight QuickScopePrimary gui=underline cterm=underline
highlight QuickScopeSecondary gui=underline cterm=underline

" Updace Visual color
" hi Visual ctermbg=17 guibg=#3e4452
" hi Search ctermbg=17 guibg=#3e4452

" Remove background color for panels vertical split separator
hi VertSplit ctermbg=NONE guibg=NONE

" airline {{{ "
let g:airline#extensions#tabline#enabled = 1
let g:airline_powerline_fonts = 1
let g:airline_theme = 'tomorrow'
" disable tmuxline extension so we configure it manually after
let g:airline#extensions#tmuxline#enabled = 0
" show only the tail of the branch name
let g:airline#extensions#branch#format = 1
let g:airline#extensions#branch#enabled = 1
" Don't show icon for dirty repository
let g:airline#extensions#branch#vcs_checks = ['untracked']
" Don't show git changes to current file in airline
let g:airline#extensions#hunks#enabled=0
let g:airline_right_sep=''
let g:airline_left_sep=''
" Show filename only instead of file path
let g:airline_section_c = '%t'
" Show filetype only, without function name
let g:airline_section_x='%{airline#util#wrap(airline#parts#filetype(),0)}'
let g:airline_section_y=''
let g:airline_section_z=''
" Disable status line, makes scroll slow
let g:airline_disable_statusline = 0
" Hack to avoid lagginess when switching between panes
" https://github.com/vim-airline/vim-airline/issues/1026#issuecomment-322134816
let g:airline_highlighting_cache=1

" disable airline to test the below one
let w:airline_disable_statusline = 1
" }}} airline "
"
"=====================================================
"===================== STATUSLINE ====================
" from: https://github.com/fatih/dotfiles/blob/master/vimrc#L138

let s:modes = {
      \ 'n': 'NORMAL', 
      \ 'i': 'INSERT', 
      \ 'R': 'REPLACE', 
      \ 'v': 'VISUAL', 
      \ 'V': 'V-LINE', 
      \ "\<C-v>": 'V-BLOCK',
      \ 'c': 'COMMAND',
      \ 's': 'SELECT', 
      \ 'S': 'S-LINE', 
      \ "\<C-s>": 'S-BLOCK', 
      \ 't': 'TERMINAL'
      \}

let s:prev_mode = ""
function! StatusLineMode()
  let cur_mode = get(s:modes, mode(), '')

  " do not update higlight if the mode is the same
  if cur_mode == s:prev_mode
    return cur_mode
  endif

  if cur_mode == "NORMAL"
    exe 'hi! StatusLine ctermfg=236'
    exe 'hi! myModeColor cterm=bold ctermbg=148 ctermfg=22'
  elseif cur_mode == "INSERT"
    exe 'hi! myModeColor cterm=bold ctermbg=23 ctermfg=231'
  elseif cur_mode == "VISUAL" || cur_mode == "V-LINE" || cur_mode == "V_BLOCK"
    exe 'hi! StatusLine ctermfg=236'
    exe 'hi! myModeColor cterm=bold ctermbg=208 ctermfg=88'
  endif

  let s:prev_mode = cur_mode
  return cur_mode
endfunction

function! StatusLineFiletype()
  return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! StatusLinePercent()
  return (100 * line('.') / line('$')) . '%'
endfunction

function! StatusLineLeftInfo()
 let branch = fugitive#head()
 let filename = '' != expand('%:t') ? expand('%:t') : '[No Name]'
 if branch !=# ''
   return printf("%s | %s", branch, filename)
 endif
 return filename
endfunction

exe 'hi! myInfoColor ctermbg=240 ctermfg=252'

" start building our statusline
set statusline=

" mode with custom colors
set statusline+=%#myModeColor#
set statusline+=%{StatusLineMode()}               
set statusline+=%*

" left information bar (after mode)
set statusline+=%#myInfoColor#
set statusline+=\ %{StatusLineLeftInfo()}
set statusline+=\ %*

" go command status (requires vim-go)
set statusline+=%#goStatuslineColor#
set statusline+=%{go#statusline#Show()}
set statusline+=%*

" right section seperator
set statusline+=%=

" filetype, percentage, line number and column number
set statusline+=%#myInfoColor#
set statusline+=\ %{StatusLineFiletype()}\ %{StatusLinePercent()}\ %l:%v
set statusline+=\ %*
"=========================================
"
" ==================== delimitMate ====================
let g:delimitMate_expand_cr = 1   
let g:delimitMate_expand_space = 1    
let g:delimitMate_smart_quotes = 1    
let g:delimitMate_expand_inside_quotes = 0    
let g:delimitMate_smart_matchpairs = '^\%(\w\|\$\)'   

" ==================== Completion + Snippet ====================
" Ultisnips has native support for SuperTab. SuperTab does omnicompletion by
" pressing tab. I like this better than autocompletion, but it's still fast.
let g:SuperTabDefaultCompletionType = "<c-n>"
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"  
let g:UltiSnipsJumpBackwardTrigger="<s-tab>" 

" Open tag under cursor in vsplit
noremap <C-W>] :vsp <CR>:exec("tag ".expand("<cword>"))<CR>

" arrow keys resize windows
nnoremap <Left> :vertical resize -10<CR>
nnoremap <Right> :vertical resize +10<CR>
nnoremap <Up> :resize -10<CR>
nnoremap <Down> :resize +10<CR>

" Vim-Dispatch
" Disable tmux handler so it defaults to Job one, which uses quicklist instead
" of tmux pane to run tests
let g:dispatch_no_tmux_make = 1

" Fugitive {{{
let g:fugitive_gitlab_domains = ['https://gitlab.otters.xyz']
let g:fugitive_gitlab_domains = ['https://gitlab.otters.xyz']
nmap <silent> <leader>-  :Gstatus<cr><c-n>
nnoremap <leader>gp :Gpull<cr>
nnoremap <silent> <leader>gb :Gblame<cr>
nnoremap <silent> <leader>gd :Gvdiff<cr>
nnoremap <silent> <leader>go :Gbrowse<cr>
xnoremap <silent> <leader>go :Gbrowse<cr>
nnoremap <silent> <leader>gl :0Glog<cr>
" }}} fugitive

" Git {{{ "
command! -nargs=0 Gmrl !lab mr -l
command! -nargs=* Gmr !lab mr -b <q-args>

nnoremap <silent> <leader>gmr :Gmr<cr>
nnoremap <leader>gmrl :Gmrl<cr>
" Git }}} "
"
" Open def in vertical/horizontal split
:nnoremap <leader>v <C-w>v
"
" vim-go {{{ "
" run :GoBuild or :GoTestCompile based on the go file
function! s:build_go_files()
  let l:file = expand('%')
  if l:file =~# '^\f\+_test\.go$'
    call go#test#Test(0, 1)
  elseif l:file =~# '^\f\+\.go$'
    call go#cmd#Build(0)
  endif
endfunction

au FileType go nmap <silent> <leader>r <Plug>(go-run)
au FileType go nmap <silent> <leader>e <Plug>(go-install)
au FileType go nmap <silent> <Leader>i <Plug>(go-info)
au FileType go nmap <silent> <Leader>v <Plug>(go-def-vertical)
au FileType go nmap <silent> <Leader>x <Plug>(go-doc-vertical)
au FileType go nmap <silent> <Leader>tc <Plug>(go-coverage-toggle)
au FileType go nmap <silent> <Leader>L <Plug>(go-metalinter)
au FileType go nmap <silent> <leader>b :<C-u>call <SID>build_go_files()<CR>
au FileType go nmap <leader>. :GoSameIdsAutoToggle<CR>
" Alternate between test and implementation file
au FileType go nmap <silent> <leader>ta :A<CR>
" Find and open respective test go file
au FileType go command! -bang A call go#alternate#Switch(<bang>0, 'edit')
au FileType go command! -bang AV call go#alternate#Switch(<bang>0, 'vsplit')
au FileType go command! -bang AS call go#alternate#Switch(<bang>0, 'split')
au FileType go command! -bang AT call go#alternate#Switch(<bang>0, 'tabe')

" use terminal buffer for console in neovim
let g:go_term_enabled = 1
let g:go_term_mode = "vsplit"

" Add go special tab identitation
autocmd FileType go setlocal noexpandtab tabstop=4 shiftwidth=4

let g:go_highlight_space_tab_error = 0
let g:go_highlight_array_whitespace_error = 0
let g:go_highlight_trailing_whitespace_error = 0
let g:go_highlight_extra_types = 0
let g:go_highlight_build_constraints = 1
let g:go_highlight_types = 0
let g:go_highlight_operators = 1
let g:go_highlight_format_strings = 0
let g:go_highlight_function_calls = 0

" disable autosave linter, we are using ALE as linter
let g:go_fmt_autosave = 0

" vim-go }}} "

" Allow to pass commands to RG
" Search by default hidden files except .git folder
command! -bang -nargs=* Rg
  \ call fzf#vim#grep(
  \ "rg --column --line-number --no-heading --color=always --hidden --smart-case " .
  \ <q-args>, 1, fzf#vim#with_preview({ 'options': '--delimiter : --nth 4..' }, 'right:50%:hidden', 'รง'), <bang>0)

" Customize fzf colors to match your color scheme.
let g:fzf_colors =
      \ { 'fg':    ['fg', 'Normal'],
      \ 'bg':      ['bg', 'Normal'],
      \ 'hl':      ['fg', 'Comment'],
      \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
      \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
      \ 'hl+':     ['fg', 'Statement'],
      \ 'info':    ['fg', 'PreProc'],
      \ 'border':  ['fg', 'Ignore'],
      \ 'prompt':  ['fg', 'Conditional'],
      \ 'pointer': ['fg', 'Exception'],
      \ 'marker':  ['fg', 'Keyword'],
      \ 'spinner': ['fg', 'Label'],
      \ 'header':  ['fg', 'Comment'] }

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Moving around, tabs, windows and buffers
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Return to last edit position when opening files (You want this!)
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

" Close the current buffer
map <leader>Bd :Bclose<cr>:tabclose<cr>gT

" Close all the buffers
map <leader>Ba :bufdo bd<cr>

map <leader>l :bnext<cr>
map <leader>h :bprevious<cr>

" Map <Space> to / (search) and Ctrl-<Space> to ? (backwards search)
map <space> /
map <C-space> ?

" Don't close window, when deleting a buffer
command! Bclose call <SID>BufcloseCloseIt()
function! <SID>BufcloseCloseIt()
  let l:currentBufNum = bufnr("%")
  let l:alternateBufNum = bufnr("#")

  if buflisted(l:alternateBufNum)
    buffer #
  else
    bnext
  endif

  if bufnr("%") == l:currentBufNum
    new
  endif

  if buflisted(l:currentBufNum)
    execute("bdelete! ".l:currentBufNum)
  endif
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Smart mappings on the command line
cno $c e <C-\>eCurrentFileDir("e")<cr>

" Bash like keys for the command line
cnoremap <C-A> <Home>
cnoremap <C-E> <End>
cnoremap <C-K> <C-U>

func! CurrentFileDir(cmd)
  return a:cmd . " " . expand("%:p:h") . "/"
endfunc

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Ale (syntax checker and linter)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
nmap <silent> <leader>n <Plug>(ale_next_wrap)

" Disabling highlighting in ALE and in vim-go
" so it doesn't open quickfix nor location list windows
" when linting
let g:ale_set_highlights = 0
let g:go_fmt_fail_silently = 1

" Only run linting when saving the file
let g:ale_lint_on_text_changed = 'never'
let g:ale_lint_on_enter = 0
let g:ale_lint_on_insert_leave=0
